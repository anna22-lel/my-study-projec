# my-study-projec
Ответы на 1 вопросы

---

БИЛЕТ №1

Модели жизненного цикла ПО

Жизненный цикл ПО — это последовательность этапов от возникновения идеи до снятия программы с эксплуатации. Выбор модели определяет порядок выполнения работ.

1. Каскадная (водопадная) модель

Характеристика: Классическая линейная модель с строго последовательными этапами. Переход к следующему этапу возможен только после полного завершения предыдущего.

· Этапы: Сбор требований → Проектирование → Разработка → Тестирование → Внедрение → Сопровождение.
· Достоинства:
  · Простота планирования и контроля.
  · Чёткая документация на каждом этапе.
  · Предсказуемость бюджета и сроков при стабильных требованиях.
· Недостатки:
  · Низкая гибкость, сложность внесения изменений.
  · Рабочий продукт появляется только в конце цикла.
  · Высокий риск несоответствия результата ожиданиям заказчика.
· Область применения: Проекты с чётко определёнными и неизменными требованиями (например, государственные заказы, системы безопасности, встроенное ПО).

---

2. Итерационная модель

Характеристика: Разработка ведётся циклами (итерациями). Каждая итерация включает все этапы каскадной модели в миниатюре и добавляет новую функциональность к предыдущему результату.

· Достоинства:
  · Возможность корректировки требований и проектных решений.
  · Раннее получение работающих прототипов.
  · Риски распределены по итерациям.
· Недостатки:
  · Общая архитектура может деградировать без тщательного контроля.
  · Требует более активного вовлечения заказчика.
· Область применения: Крупные проекты, где требования могут уточняться, и необходим быстрый вывод базового функционала (корпоративные системы, сложное веб-приложение).

---

3. Спиральная модель

Характеристика: Циклическая модель, фокусирующаяся на оценке и минимизации рисков. Каждый виток спирали включает четыре фазы: планирование, анализ рисков, разработку и оценку.

· Достоинства:
  · Акцент на раннем выявлении и управлении рисками.
  · Подходит для очень больших, сложных и инновационных проектов.
  · Сочетает итеративность и системный анализ.
· Недостатки:
  · Высокая стоимость и сложность управления.
  · Требует высокой квалификации в области анализа рисков.
· Область применения: Проекты с высокой степенью неопределённости, критичные к надёжности и безопасности (аэрокосмическая отрасль, оборонные системы, медицинское оборудование).

---

Вывод: Выбор модели зависит от характера проекта: каскадная — для стабильных требований, итерационная — для динамичных проектов, спиральная — для уникальных проектов с высокими рисками. Современная разработка чаще использует гибкие (Agile) методологии, основанные на итерационном подходе.

---

БИЛЕТ №2

### Система управления версиями (VCS):
Позволяет отслеживать изменения файлов, хранить историю правок и упрощает коллективную разработку.

#### Основные понятия:
- Репозиторий:Хранилище проекта с историей изменений.
- Коммит:Фиксированная версия проекта с описанием изменений.
- Ветка:Параллельная линия разработки для экспериментов или отдельных функций.

#### Популярные системы:
- Git:Распределённая система, быстрая и удобная для команд разной величины.
- SVN:Централизованная система, простая в освоении, часто применяется в корпоративной среде.

---

БИЛЕТ №3

Тестирование ПО

Тестирование ПО — процесс проверки соответствия программы требованиям и выявления дефектов.

Уровни тестирования (по объему тестируемого кода)

1. Модульное (Unit-тестирование)
   Что: Тестирование отдельных функций, методов или классов.
   Кто: Разработчики.
   Когда: Во время написания кода.
   Инструменты: JUnit (Java), pytest (Python), Jest (JavaScript).
2. Интеграционное (Integration testing)
   Что: Проверка взаимодействия нескольких модулей/компонентов между собой.
   Пример: Тест взаимодействия модуля «Корзина» с модулем «Оплата».
   Цель: Обнаружение ошибок в интерфейсах и передаче данных.
3. Системное (System testing)
   Что: Тестирование всей системы целиком как готового продукта.
Цель: Проверить соответствие требованиям из ТЗ. Выполняется на окружении, максимально близком к боевому.

Виды тестирования (по целям)

1. Функциональное
   Что: Проверка, что функция работает согласно требованиям.
   Пример: «При нажатии кнопки "Отправить" форма должна сохраняться в базе данных».
2. Нагрузочное (Load testing)
   Что: Проверка работы системы под высокой нагрузкой (много пользователей одновременно).
   Цель: Оценить производительность и стабильность.
   Инструменты: JMeter, Gatling.
3. Регрессионное (Regression testing)
   Что: Повторное тестирование уже проверенных функций после внесения изменений в код.
   Цель: Убедиться, что новые изменения не сломали существующую функциональность.

БИЛЕТ №4

Документирование ПО

Документирование — создание текстовых и графических материалов, описывающих ПО для разных аудиторий.

Виды документации

1. Пользовательская — для конечных пользователей:
   · Руководство пользователя
   · Справочная система
   · Руководство администратора (установка, настройка)
2. Техническая — для разработчиков:
   · Техническое задание (ТЗ) — требования
   · Архитектурное описание
   · Документация API
   · Комментарии в коде
3. Проектная — для управления:
   · План проекта
   · Отчеты, протоколы


Стандарты для ТЗ (технического задания)

В России часто используют ГОСТ 34.602-89. Основные разделы:

1. Общие сведения (название, заказчик, исполнитель)
2. Назначение и цели (зачем создается система)
3. Требования к системе (функциональные, к надежности, безопасности)
4. Стадии и этапы разработки
5. Порядок контроля и приемки
6. Требования к документации

Ключевой принцип: ТЗ должно быть четким, однозначным и проверяемым (требования должны иметь критерии выполнения).


БИЛЕТ №5

Рефакторинг — это улучшение структуры существующего кода без изменения его внешнего поведения. Это не исправление ошибок и не добавление новых функций.

Цели рефакторинга:

1. Упростить понимание кода (для себя и команды)
2. Уменьшить сложность и убрать дублирование
3. Облегчить добавление новых функций в будущем
4. Снизить риск ошибок при изменениях

Когда нужен рефакторинг (критерии):

1. Запахи кода (длинные методы, большие классы, дублирование)
2. Перед добавлением новой функции — если код запутан, сначала прибери
3. При исправлении бага — если нашли причину, улучшите код вокруг неё
4. Во время код-ревью — если коллеги указали на проблемные места

Основные приёмы (простые):

1. Переименование переменных, методов, классов — чтобы названия говорили сами за себя
2. Выделение метода — разбить длинный метод на несколько маленьких
3. Выделение класса — разделить большой класс на несколько маленьких
4. Устранение дублирования — вынести одинаковый код в один метод
5. Упрощение условных выражений — заменить сложные if на понятные условия

Связь с техническим долгом:

Технический долг — это последствия плохого кода, которые замедляют разработку. Как финансовый долг — чем дольше не возвращаешь, тем больше процентов.

· Рефакторинг = выплата процентов по техдолгу
· Плохой код + отсутствие рефакторинга = рост техдолга
· Большой техдолг = невозможно быстро добавлять функции, много багов

БИЛЕТ №6 и №9

Контроль версий (Git) — система, фиксирующая все изменения кода для возможности отката и командной работы.

Отличие Git от GitHub:

· Git — локальная программа для управления версиями.
· GitHub — облачная платформа для хранения репозиториев Git.

Ключевые понятия:

1. Репозиторий — хранилище файлов проекта и их истории.
2. Коммит — сохранённый снимок изменений с комментарием.
3. Ветка — изолированная линия разработки для новых функций.
4. Слияние — объединение изменений из разных веток.

Зачем нужно:

· Возврат к рабочей версии при ошибках.
· Параллельная работа команды.
· Сохранение всей истории изменений.
· Резервное копирование в облаке.

---

БИЛЕТ №7

1. Совместная разработка на GitHub:

· Pull Request
Основные понятия:

Fork — полная копия чужого репозитория на ваш аккаунт GitHub. Позволяет вносить изменения без прямого доступа к исходному проекту.

Pull Request (PR / Merge Request) — запрос на слияние ваших изменений с основным репозиторием. Это основной механизм внесения изменений в командных проектах.

Code Review — процесс проверки кода другими разработчиками перед слиянием. Цель: улучшение качества, поиск ошибок, обмен знаниями.

---

Процесс работы в команде через GitHub (стандартный workflow):

1. Fork основного репозитория → у вас появляется личная копия.
2. Клонируете свой форк на компьютер (git clone).
3. Создаёте новую ветку для задачи (git checkout -b feature-new).
4. Пишете код, делаете коммиты.
5. Пушите ветку в свой форк (git push origin feature-new).
6. В GitHub создаёте Pull Request из вашей ветки в основную ветку (main) оригинального репозитория.
7. Проходите Code Review: другие участники оставляют комментарии, вы вносите правки и обновляете PR.
8. После одобрения модератор сливает (merge) ваш PR в основной проект.


БИЛЕТ №8

Запах кода-Это признак плохого дизайна, который усложняет поддержку кода. Не ошибка, но сигнал, что нужно рефакторить.

5 примеров

1. Длинный метод

· Проблема: Метод на 100+ строк. Невозможно понять, что он делает. Тестировать — кошмар.
· Исправление: Разделить на несколько маленьких методов.

2. Большой класс

· Проблема: Класс делает всё. 50+ методов. Нарушен принцип единственной ответственности.
· Исправление: Выделить из него 2-3 отдельных класса по смыслу.

3. Дублирование кода

· Проблема: Одинаковый код в разных местах. Изменение — искать и править везде.
· Исправление: Вынести общую логику в один метод/класс и переиспользовать.

4. Длинный список параметров

· Проблема: Метод с 5+ параметрами. Легко перепутать порядок.
· Исправление: Сгруппировать связанные параметры в объект (DTO) и передавать его.

5. Цепочка вызовов

· Проблема: obj.getA().getB().getC(). Приводит к NullPointerException.
· Исправление: Использовать паттерн Null Object или делегировать вызовы внутрь основного объекта.


БИЛЕТ №10

Диаграмма вариантов использования (Use Case Diagram)

Что это: Карта-схема, которая показывает, что может делать система с точки зрения пользователя. Отвечает на вопрос: "Система умеет вот это, это и это".

Основные элементы:

1. Актор (Actor)
   · Что: Человечек или класс со стрелочкой.
   · Зачем: Роль, которая использует систему извне (Пользователь, Админ, другая система). Находится за границей системы.
2. Вариант использования (Use Case)
   · Что: Овал с названием.
   · Зачем: Одно цельное действие, которое система выполняет по запросу актора ("Оформить заказ", "Найти книгу").
3. Ассоциация (Association)
   · Что: Сплошная линия без стрелок.
   · Зачем: Просто показывает, что актор взаимодействует с вариантом использования.
4. Зависимости (Dependencies) — важнейшие два типа:
   а) <<include>> (Включение)
   · Что: Пунктирная стрелка от основного Use Case к включаемому с надписью <<include>>.
   · Зачем: Показывает обязательную часть ("чтобы сделать А, система всегда должна сделать Б"). Пример: "Оплатить заказ" включает "Проверить баланс".
   б) <<extend>> (Расширение)
   · Что: Пунктирная стрелка от расширяющего Use Case к основному с надписью <<extend>>. На стрелке пишут условие.
   · Зачем: Показывает необязательное, дополнительное поведение ("система может сделать Б при условии X, расширяя А"). Пример: "Сменить тариф" расширяет "Просмотреть профиль" [если пользователь премиум].

---

БИЛЕТ №11 и №12

Что показывает диаграмма последовательности?

Это карта порядка обмена сообщениями между объектами для выполнения одного сценария. Показывает, кто, кому, когда и что передаёт. Время течёт сверху вниз.

Назначение ключевых элементов:

1. Линия жизни (Lifeline / Объект)
   · Что: Прямоугольник сверху + пунктирная линия вниз.
   · Зачем: Показывает участника взаимодействия (объект, актёр, систему). Вертикальная линия — это ось времени его жизни.
2. Сообщения (Messages)
   · Что: Стрелки между линиями жизни.
   · Зачем: Показывают вызовы, запросы или данные, которые один объект отправляет другому. Типы стрелок:
     · → (сплошная) — синхронный вызов (например, вызов метода, ждёт ответ).
     · ----→ (пунктирная) — асинхронное сообщение (не ждёт).
     · ----> (пунктирная со стрелкой) — возврат/ответ.
3. Полоса активации (Activation Bar)
   · Что: Тонкий прямоугольник на линии жизни.
   · Зачем: Показывает период, когда объект активно выполняет действие (обрабатывает сообщение, выполняет свой метод). Чем длиннее полоса, тем дольше выполнение.
4. Рамка взаимодействия (Interaction Frame)
   · Что: Прямоугольная область с меткой в левом верхнем углу.
   · Зачем: Группирует логически связанные сообщения для описания особой логики. Это "операторы" для диаграмм.

Ответы на 2 вопросы.
БИЛЕТ 1
2) Практическое задание: План перехода на современную ОС
Цель: Бесперебойный переход 30 сотрудников с Windows 7/8.1 на Windows 10/11 с сохранением данных и работоспособности.
Этапы:
Этап 1: Подготовка и аудит (1-2 недели)
1.	Инвентаризация: Составить список всего оборудования (ПК, ноутбуки) и проверить его совместимость с Windows 10/11 с помощью официального инструмента PC Health Check.
2.	Аудит ПО: Составить полный перечень используемого программного обеспечения (бухгалтерские программы, 1С, офисные пакеты, специфичное ПО) и проверить его совместимость на сайте производителей.
3.	Определение прав: Уточнить, каким пользователям нужны права администратора для работы.
Этап 2: Пилотное внедрение (1 неделя)
1.	Выбор группы: Выбрать 2-3 ПК разных конфигураций и пользователей с разными потребностями.
2.	Резервное копирование: Полностью создать бэкап систем и пользовательских данных (документы, рабочие столы, закладки браузеров) с помощью средств Windows или инструментов вроде Veeam Agent.
3.	Чистая установка ОС: Выполнить чистую установку Windows 10/11 (рекомендуется вместо обновления) на пилотные ПК.
4.	Тестирование: Установить и протестировать все необходимое ПО на новой ОС. Убедиться, что периферия (принтеры, сканеры) работает.
Этап 3: Подготовка к массовому внедрению (1 неделя)
1.	Создание эталонного образа: На основе успешного пилотного ПК создать унифицированный образ системы с уже установленным и настроенным ПО.
2.	Разработка инструкций: Подготовить пошаговые инструкции для пользователей (как войти в систему, где найти программы, основные изменения в интерфейсе).
3.	Планирование графика: Составить график перехода по отделам, чтобы не парализовать работу всей компании.
Этап 4: Массовое развертывание и обучение (2-3 недели)
1.	Рассылка уведомлений: Заблаговременно уведомить сотрудников о времени перехода.
2.	Резервное копирование: Перед переходом каждого пользователя делать бэкап его данных.
3.	Развертывание: Установить ОС с помощью образа (средствами MDT/WDS) для ускорения процесса.
4.	Обучение: Провести 1-2 часовые обучающие семинары для сотрудников, акцентируя внимание на новых элементах интерфейса (Меню "Пуск", Настройки) и ответах на частые вопросы.
5.	Поддержка: Обеспечить усиленную техническую поддержку в первые дни после перехода.
Этап 5: Завершение и пост-поддержка
1.	Документирование: Зафиксировать все возникшие проблемы и их решения.
2.	Деактивация старых ОС: Убедиться, что все компьютеры переведены, а старые системы выведены из эксплуатации.
Билет 2, 3, 4,5, 8 -тех задание
Билет 6 
Организация работы с GitHub для учебного проекта
1. Создание репозитория
Шаг 1. Перейдите на сайт GitHub и войдите в свой аккаунт.
Шаг 2. Нажмите кнопку New repository (Создать репозиторий).
Шаг 3. Заполните основные параметры:
Название репозитория (например, my-project)
Описание проекта (краткое описание функционала)
Выберите тип видимости (публичный/приватный)
Добавьте README.md файл (опционально)
Шаг 4. Нажмите Create repository для создания репозитория.
2. Добавление файла README.md
Шаг 5. После создания репозитория откройте его в браузере.
Шаг 6. В интерфейсе репозитория нажмите кнопку Add file (Добавить файл).
Шаг 7. Создайте файл README.md и добавьте базовое описание проекта:

# Название проекта

Описание проекта

### Установка
Инструкция по установке

### Использование


Основные возможности
3. Создание структуры папок
Шаг 8. В корне репозитория создайте основные папки:
src/ — для основного кода проекта
docs/ — документация и инструкции
tests/ — тестовые файлы
4. Правила именования
Имена файлов:
Используйте понятные названия
Применяйте осмысленные расширения (.js, .py, .html)
Избегайте специальных символов
Коммиты:
Каждый коммит должен иметь осмысленное описание
Используйте формат: Тип изменения: описание
Пример: Fix: Исправлено форматирование кода
5. Создание первого коммита
Шаг 9. Откройте терминал в папке проекта.
Шаг 10. Выполните команды:


git init
git add .
git commit -m "Initial commit: added README and project structure"
git push origin main

Билет№7
Организация workflow командной разработки:

1. Создание и настройка репозитория команды
Создать organization на GitHub или общий репозиторий
Добавить всех участников команды с правами доступа
Настроить защиту ветки main (требовать review перед мержем)
Добавить шаблоны для issues и pull requests
Настроить .gitignore под технологии проекта
2. Стратегия работы с ветками (GitHub Flow для простоты)
main — всегда стабильная версия
Для каждой задачи создаётся новая ветка от main
Именование веток: feat/..., fix/..., docs/...
Работа ведётся только в своей ветке
3. Процесс создания Pull Request
После завершения работы пушим ветку на GitHub
Создаём Pull Request (ветка → main)
Заполняем шаблон: что сделано, как тестировать
Прикрепляем ссылку на задачу (issue)
Назначаем ревьюеров
4. Проверка кода (чек-лист)
Код решает поставленную задачу?
Соответствует стилю проекта?
Нет ли грубых ошибок?
Тесты добавлены/проходят?
Комментарии понятны?
5. Слияние и конфликты
После одобрения ревьюером делаем merge
Используем squash merge для чистоты истории
При конфликтах: автор PR обновляет свою ветку, разрешает конфликты локально, пушит исправления
После мержа удаляем ветку задачи
Билет№9
 Работа с GitHub для учебного проекта:

1)Создание репозитория и README.md
New repository на GitHub
Имя проекта, галочка "Add README"
Создать
2)Структура папок через веб-интерфейс
Add file → Create new file
Создать: src/, docs/, tests/
В каждой — файл .gitkeep для сохранения пустых папок

3).gitignore для Python
Создать файл .gitignore

Добавить стандартные исключения:

text
__pycache__/
*.pyc
venv/
.env

4)Правила коммитов (Conventional Commits)
Формат: тип: описание
Основные типы: feat:, fix:, docs:, test:
Пример: docs: обновить README

5)Первый коммит через командную строку

bash
git clone [ссылка-на-репозиторий]
cd [папка-проекта]
echo "Код проекта" > src/main.py
git add .
git commit -m "feat: добавить основной модуль"
git push origin main

Билет 10,11,12(фото диаграммы в отд фай)
Ответы на 3 задание
Анюта, [25.12.2025 18:03]
Ответы на 3 вопрос


БИЛЕТ №1

3. Пользователь жалуется на медленную работу компьютера после установки но

СИТУАЦИОННАЯ ЗАДАЧА: Диагностика медленной работы ПК

ДИАЛОГ С ПОЛЬЗОВАТЕЛЕМ:

1. Уточните: «Какое приложение установили? Когда начались проблемы?»
2. Спросите: «В чём конкретно проявляется медлительность? (загрузка, программы, интернет)»
3. Узнайте: «Появляются ли ошибки? Что уже пробовали?»

ВАШИ ДЕЙСТВИЯ (алгоритм):

1. Откройте Диспетчер задач (Ctrl+Shift+Esc):
   · Проверьте вкладку «Автозагрузка» — отключите новое приложение, если оно там есть.
   · На вкладке «Процессы» найдите процессы нового приложения, потребляющие много ЦП, памяти или диска.
2. Выполните чистую загрузку (через msconfig или «Параметры» → «Конфигурация системы»):
   · Отключите все сторонние службы и автозагрузку → перезагрузитесь.
   · Если скорость восстановилась — причина в конфликте ПО.
3. Проверьте антивирусом (если есть подозрения на вредоносное ПО).
4. Удалите проблемное приложение (если предыдущие шаги подтвердили его вину):
   · Через «Панель управления» → «Программы и компоненты».
   · Используйте специальные деинсталляторы (например, Revo Uninstaller) для полного удаления.
5. Дополнительные меры:
   · Очистите временные файлы (Disk Cleanup).
   · Обновите драйверы видеокарты/чипсета.

---

БИЛЕТ №2

3. При групповой работе над кодом в Git возник конфликт слияния (merge conflict).

Последовательность действий для разрешения:

1. Конфликт — ситуация при параллельном редактировании одних и тех же строк.
2. Выполнить git status. Git укажет файлы с конфликтами (both modified).
3. Открыть конфликтный файл в редакторе. Git помечает конфликтующие участки специальными маркерами:
   · <<<<<<< HEAD — ваши изменения.
   · ======= — разделитель.
   · >>>>>>> branch_name — изменения из сливаемой ветки.
4. Вручную отредактировать файл, выбрав нужные изменения или скомбинировав их. Удалить маркеры Git.
5. Сохранить файл, добавить исправление в индекс: git add <имя_файла>.
6. Завершить слияние коммитом: git commit. Git предложит стандартное сообщение.
7. Проверить, что все работает, и отправить изменения: git push.

---

БИЛЕТ №3

3. Заказчик просит добавить в почти готовый проект новую функцию, которая не была в ТЗ.

Мои действия и аргументы:

1. Внимательно выслушать и понять суть запроса, его ценность для бизнеса.
2. Объяснить последствия :
   · Сроки: Добавление функции отложит релиз.
   · Бюджет: Потребуются дополнительные бюджет.
   · Содержание/Качество: Могут пострадать текущие функции из-за спешки.
3. Предложить варианты:
   · Вариант А (идеальный): Вынести функцию в отдельную фазу проекта (версию 2.0), которую мы спланируем после релиза текущей версии.
   · Вариант Б (компромиссный): Реализовать упрощенную (минимальную) версию функции сейчас, если это не нарушит архитектуру и сроки.
   · Вариант В (жесткий): Добавить функцию сейчас, но официально пересмотреть сроки, бюджет и утвердить изменения в ТЗ.
Изменения возможны, но они должны быть управляемыми и документально зафиксированными.


---

БИЛЕТ №4 и №9

3. Коллега написал плохо читаемый код без комментариев. Вам предстоит дорабатывать этот модуль.


Мои шаги:

1. Сначала разобраться, что делает код
   · Запущу его, проверю на разных данных
   · Если непонятно — спрошу у автора кратко: «Объясни, пожалуйста, основную логику этого модуля»
2. Зафиксировать текущее поведение тестами
   · Напишу несколько простых тестов, которые проверяют ключевые функции
3. Улучшать постепенно и безопасно
   · Переименую переменные и функции
   · Разобью длинные функции на маленькие
   · Упрощу сложные условия
   · Добавлю комментарии только к сложной бизнес-логике, а не к очевидным вещам
4. Проверка и обсуждение
   · Запущу все тесты — убежусь, что ничего не сломал
   · Покажу изменения автору через code review: «Я немного переработал модуль для читаемости, проверь, пожалуйста»
5. Чтобы проблема не повторялась (предложение команде):
   · Ввести общие правила оформления кода в проекте
   · Подключить автоматические проверки стиля (линтеры)
   · Делать code review всех новых изменений


---

БИЛЕТ №5

Тестировщик и разработчик спорят, баг это или особенность.

Как разрешить ситуацию:

1. Выступить в роли модератора. Собрать краткое совещание с обоими.
2. Обратиться к формальному источнику истины — Требованиям (ТЗ, пользовательские истории, спецификация). Если поведение системы соответствует документации — это особенность. Если нет — баг.
3. Если требования расплывчаты:
   · Обсудить, какое поведение логично и удобно для пользователя.
   · Привлечь продукт-менеджера или аналитика как представителя интересов заказчика/пользователя для финального вердикта.
4. Результат: Принять решение и при необходимости обновить документацию, чтобы подобные споры не повторялись.

---

БИЛЕТ №6

3. Вы случайно удалили важный файл из проекта. Как восстановить с помощью Git?

Последовательность действий:

1. Не коммитить новые изменения (если удаление не закоммичено).
2. Проверить статус: git status. Увидите удаленный файл как "deleted".
3. Восстановить файл из индекса (если он там был): git checkout -- <имя_файла>.
4. Если удаление уже закоммичено, нужно найти коммит, в котором файл еще существовал:
   · Посмотреть историю файла: git log --oneline -- <имя_файла>.
   · Восстановить файл из конкретного коммита: git checkout <хэш_коммита>^ -- <имя_файла> (символ ^ означает "из предыдущего коммита").
5. Если не помните точное имя файла: Воспользоваться git log --all --full-history -- "**/<часть_имени>*" или искать по содержимому.

---

БИЛЕТ №7

3. Два разработчика изменили один файл. При слиянии возник конфликт.

Как правильно его разрешить:
(Алгоритм аналогичен БИЛЕТ №2, но с акцентом на командную работу)

1. Связаться с коллегой, чьи изменения конфликтуют с вашими. Обсудить, какая логика должна быть в итоговой версии.
2. Локально выполнить слияние (git merge), если вы мержите ветку, или обновить свою ветку (git pull), если конфликт возник при этом.
3. Отредактировать файл, совместно приняв решение о том, какие строки оставить. Важно не просто взять свои изменения, а создать корректный итоговый код.
4. Протестировать исправленную функциональность.
5. Закоммитить результат слияния (git commit).
6. Рекомендация на будущее: Четче распределять задачи по файлам/модулям или чаще синхронизироваться (делать pull/merge из основной ветки).

---

БИЛЕТ №8

Проблема

Код стал запутанным, изменение одного модуля ломает другие.

Диагностика

1. Проверить зависимости: Есть ли модули, которые слишком много знают друг о друге?
2. Найти "божественные классы": Большие модули, делающие всё подряд.
3. Обнаружить циклы: Когда модуль А зависит от Б, а Б зависит от А.

Решение

1. Срочные меры:
   · Добавить модульные тесты к критичным частям.
   · Запретить создание новых связей между несвязанными модулями.
2. Технические шаги:
   · Разделить большие модули на маленькие (принцип одной ответственности).
   · Использовать Dependency Injection: модули должны получать зависимости извне.
   · Определить чёткие интерфейсы для общения между модулями.
3. Организационные изменения:
   · Ввести Code Review с проверкой архитектуры.
   · Выделять время на рефакторинг в каждом спринте.
   · Создать правила проектирования для новых функций.

План действий

1. Выбрать самый проблемный модуль.
2. Изолировать его: вынести общее в отдельные библиотеки.
3. Постепенно применять этот подход к остальным модулям.

---

БИЛЕТ №10

3. Как Use Case Diagram поможет структурировать пожелания заказчика?

Процесс и польза:

1. Выявление акторов: Из пожеланий станет ясно, кто взаимодействует с системой (клиент, менеджер, бухгалтер).
2. Определение границ: Четко видно, что входит в систему (варианты использования), а что остается за ее пределами (действия актора вне системы).
3. Структурирование и группировка: Разрозненные пожелания превращаются в логические группы функций (например, "Работа с заказом", "Управление каталогом").
4. Выявление противоречий: Можно обнаружить, что два описанных сценария противоречат друг другу или дублируют функционал.
5.

Анюта, [25.12.2025 18:03]
Уточнение через диалог: Процесс рисования диаграммы — повод задать заказчиту конкретные уточняющие вопросы: "Кто должен выполнять эту функцию?", "Что должно произойти, если...?".

Итог: Диаграмма превращает "хотелки" в согласованный, наглядный и структурированный перечень требований, понятный обеим сторонам.

---

БИЛЕТ №11 и №12

3. Как Sequence Diagram поможет локализовать этап сбоя?

Использование для диагностики:

1. Построить диаграмму "как должно быть" на основе документации.
2. Построить диаграмму "как есть на самом деле" при тех условиях, когда возникает ошибка. Для этого нужно добавить логирование или использовать отладчик, чтобы зафиксировать реальный порядок и содержание сообщений.
3. Сравнить две диаграммы. Расхождение укажет на проблемный этап:
   · Сообщение отправляется не тому объекту?
   · Последовательность нарушена?
   · Ответное сообщение (или исключение) не приходит?
   · Данные в сообщении некорректны?
4. Обсуждение с командой: Наглядная диаграмма становится общим языком. Вместо абстрактных споров ("функция глючит") можно указать пальцем: "Вот здесь, на шаге 5, сервис платежей возвращает не тот код ошибки". Это фокусирует обсуждение на конкретной причине.
